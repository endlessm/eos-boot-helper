#!/usr/bin/python3
#
# eos-update-flatpak-repos: adds standard flatpak repos, removes legacy remotes
# and runtimes, and migrates installed flatpaks between origins
#
# Copyright (C) 2017 Endless Mobile, Inc.
# Authors:
#  Mario Sanchez Prada <mario@endlessm.com>
#  Philip Chimento <philip@endlessm.com>
#  Robert McQueen <rob@endlessm.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import argparse
import fnmatch
import glob
import logging
import os
import shutil
import subprocess

from systemd import journal

import gi
gi.require_version('Flatpak', '1.0')
gi.require_version('OSTree', '1.0')
from gi.repository import Flatpak, Gio, GLib, OSTree


def _flatpak_inst_get_remote(inst, name):
    try:
        remote = inst.get_remote_by_name(name)
    except GLib.Error:
        remote = None

    return remote


FLATPAK_REPO_DIR = os.getenv('EOS_FLATPAK_REPO_DIR',
                             '/usr/share/eos-boot-helper/flatpak-repos')


def _add_flatpak_repos():
    insts = Flatpak.get_system_installations()
    inst = insts[0]

    for f in os.listdir(FLATPAK_REPO_DIR):
        if not f.endswith('.flatpakrepo'):
            continue

        name = f[:-12]

        repo_file = os.path.join(FLATPAK_REPO_DIR, f)

        if not os.path.isfile(repo_file):
            continue

        remote = _flatpak_inst_get_remote(inst, name)

        if remote:
            logging.debug("Remote {} already configured in {}"
                          .format(name, inst.get_path().get_path()))
            continue

        logging.info("Adding remote {} to {} from {}"
                     .format(name, inst.get_path().get_path(), repo_file))

        subprocess.check_call(['flatpak', 'remote-add', '--system',
                               '--from', name, repo_file])


# list of ostree refs
OSTREE_REFS_TO_REMOVE = [
    # remove eos3.3 refs leaked by eos-updater checkpoint bug (T23410)
    'eos:os/eos/amd64/eos3',
    'eos:os/eos/ec100/eos3',
    'eos:os/eos/nexthw/eos3'

    # remove eos2 ref left behind after eos-upgrade-eos2-to-eos3 (T23443)
    'eos:eos2/ec100',
    'eos:eos2/i386',

    # remove "initial factory commit" ref from pre-2.3.1 (T23443)
    'local:factory',
]


def _remove_ostree_refs():
    try:
        repo = OSTree.Repo.new_default()
        repo.open()
        _, ostree_refs = repo.list_refs() # dictionary of ref -> commit
        for ref in OSTREE_REFS_TO_REMOVE:
            if ref in ostree_refs:
                logging.info('Deleting leaked OSTree ref {}'.format(ref))
                repo.set_ref_immediate(ref.split(':')[0], ref.split(':')[1],
                                       None)
    except Exception:
        logging.exception('Failure deleting leaked OSTree refs')


# list of remote names
REMOTES_TO_REMOVE = [
]


def _remove_remotes():
    insts = Flatpak.get_system_installations()
    inst = insts[0]

    for name in REMOTES_TO_REMOVE:
        if _flatpak_inst_get_remote(inst, name):
            logging.info("Removing remote {} from {}"
                         .format(name, inst.get_path().get_path()))

            subprocess.check_call(['flatpak', 'remote-delete',
                                   '--system', '--force', name])


# dict of remote -> list of runtimes
RUNTIMES_TO_REMOVE = {
}


def _remove_runtimes():
    insts = Flatpak.get_system_installations()
    inst = insts[0]

    for ref in inst.list_installed_refs_by_kind(Flatpak.RefKind.RUNTIME):
        origin = ref.get_origin()
        if ref.get_origin() not in RUNTIMES_TO_REMOVE:
            continue

        name = ref.get_name()
        if name not in RUNTIMES_TO_REMOVE[origin]:
            continue

        refspec = '{}/{}/{}'.format(name, ref.get_arch(), ref.get_branch())
        logging.info("Removing runtime {} from {}"
                     .format(refspec, inst.get_path().get_path()))
        subprocess.check_call(['flatpak', 'uninstall', '--system',
                               '--runtime', refspec])


def _update_deploy_file_with_origin(deploy_file_path, new_origin_name):
    _update_deploy_file(deploy_file_path, 0, new_origin_name)


def _update_deploy_file(deploy_file_path, idx, new_val):
    logging.debug("Reading data from the deploy file at {}..."
                  .format(deploy_file_path))

    src_file_contents = None
    with open(deploy_file_path, 'rb') as f:
        src_file_contents = GLib.Bytes.new(f.read())

    # We need to read the GVariant in the deploy file and generate a
    # new one with all the same content but the right remote set.
    variant_type = GLib.VariantType.new('(ssasta{sv})')
    orig_variant = GLib.Variant.new_from_bytes(variant_type,
                                               src_file_contents, False)
    logging.debug("Original variant: {}".format(str(orig_variant)))

    cur_val = orig_variant[idx]
    if cur_val == new_val or (isinstance(cur_val, list) and
                              isinstance(new_val, list) and
                              set(cur_val) == set(new_val)):
        logging.info('Nothing to do, {}[{}] already set to: {}'
                     .format(deploy_file_path, idx, new_val))
        return

    builder = GLib.VariantBuilder.new(variant_type)
    for i, val in enumerate(orig_variant):
        child = orig_variant.get_child_value(i)
        if i == idx:
            builder.add_value(GLib.Variant(child.get_type_string(), new_val))
        else:
            builder.add_value(child)

    new_variant = builder.end()
    logging.debug("New variant: {}".format(str(new_variant)))

    # Replace the original deploy file with the new GVariant
    logging.info("Writing new deploy file for {}, setting [{}] to: {}"
                 .format(deploy_file_path, idx, new_val))
    GLib.file_set_contents(deploy_file_path,
                           new_variant.get_data_as_bytes().get_data())


FLATPAKS_TO_MIGRATE = [
    # migrate EknServices from old eos-apps remote to eos-sdk (T17863)
    {
        'name': 'com.endlessm.EknServices',
        'kind': Flatpak.RefKind.APP,
        'old-origin': 'eos-apps',
        'new-origin': 'eos-sdk'
    },
    # fix up image-builder bug where com.endlessm.apps.* runtimes were
    # mistakenly installed with eos-runtimes origin (T18366)
    {
        'name': 'com.endlessm.apps.Platform',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-origin': 'eos-runtimes',
        'new-origin': 'eos-sdk'
    },
    {
        'name': 'com.endlessm.apps.Sdk',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-origin': 'eos-runtimes',
        'new-origin': 'eos-sdk'
    },
    # migrate Steam from eos-apps to flathub (T20322)
    {
        'name': 'com.valvesoftware.Steam',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate org.gnome.* from gnome-apps to flathub (T19898)
    {
        'prefix': 'org.gnome.',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'stable',
        'old-origin': 'gnome-apps',
        'new-origin': 'flathub'
    },
    # migrate Teeworlds and MegaGlest from eos-apps to flathub (T20411)
    {
        'name': 'com.teeworlds.Teeworlds',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.megaglest.MegaGlest',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Atom from eos-apps to flathub (T20301)
    {
        'name': 'io.atom.Atom',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate gnome 3.2[46] and freedesktop 1.6 runtimes to flathub (T20443)
    {
        'prefix': 'org.freedesktop.',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-branch': '1.6',
        'old-origin': 'gnome',
        'new-origin': 'flathub'
    },
    {
        'prefix': 'org.gnome.',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-branch': '3.24',
        'old-origin': 'gnome',
        'new-origin': 'flathub'
    },
    {
        'prefix': 'org.gnome.',
        'kind': Flatpak.RefKind.RUNTIME,
        'old-branch': '3.26',
        'old-origin': 'gnome',
        'new-origin': 'flathub'
    },
    # migrate eos-apps to flathub where the app ID is the same (T20724)
    {
        'name': 'com.google.AndroidStudio',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'com.slack.Slack',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'com.spotify.Client',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'com.transmissionbt.Transmission',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'net.minetest.Minetest',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.freeciv.Freeciv',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.gnome.Builder',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.gnome.Genius',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.gnome.Gnote',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.inkscape.Inkscape',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.pitivi.Pitivi',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.tuxpaint.Tuxpaint',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.videolan.VLC',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    {
        'name': 'org.wesnoth.Wesnoth',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Visual Studio Code OSS from eos-apps to flathub (T20306)
    {
        'name': 'com.visualstudio.code.oss',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Sublime Text from eos-apps to flathub (T22875)
    {
        'name': 'com.sublimetext.three',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Photo Editor from eos-apps to flathub (T21891)
    {
        'name': 'com.endlessm.photos',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Dropbox from eos-apps to flathub (T23174)
    {
        'name': 'com.dropbox.Client',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    },
    # migrate Stellarium from eos-apps to flathub (T23681)
    {
        'name': 'org.stellarium.Stellarium',
        'kind': Flatpak.RefKind.APP,
        'old-branch': 'eos3',
        'new-branch': 'stable',
        'old-origin': 'eos-apps',
        'new-origin': 'flathub'
    }
]


def _filter_refs(refs, name=None, prefix=None, kind=None, arch=None,
                 branch=None, origin=None):
    ret = []
    for ref in refs:
        if kind and kind != ref.get_kind():
            continue
        if name and name != ref.get_name():
            continue
        if prefix and not ref.get_name().startswith(prefix):
            continue
        if arch and arch != ref.get_arch():
            continue
        if branch and branch != ref.get_branch():
            continue
        if origin and origin != ref.get_origin():
            continue
        ret.append(ref)
    return ret


def _filter_ostree_refs(refs, origin, kind, name='*', prefix=None, arch='*',
                        branch='*'):
    assert origin
    assert kind.value_nick in {'app', 'runtime'}

    if prefix:
        name = '{}*'.format(prefix)

    pattern = '{}:{}/{}/{}/{}'.format(origin, kind.value_nick, name, arch, branch)

    return fnmatch.filter(refs, pattern)


COMMIT_SUBJECT_INDEX = 3
COMMIT_BODY_INDEX = 4


def copy_commit(repo, src_rev, dest_ref, collection_id=None):
    """Copy commit src_rev to dest_ref
    This makes the new commit at dest_ref have the proper collection
    binding for this repo. The caller is expected to manage the
    ostree transaction.
    This is like "flatpak build-commit-from", but we need more
    control over the transaction.
    """
    logging.info('Copying commit %s to %s', src_rev, dest_ref)

    _, src_root, _ = repo.read_commit(src_rev)
    _, src_variant, src_state = repo.load_commit(src_rev)

    # Only copy normal commits
    if src_state != 0:
        raise Exception('Cannot copy irregular commit {}'
                        .format(src_rev))

    # If the dest ref exists, use the current commit as the new
    # commit's parent
    _, dest_parent = repo.resolve_rev_ext(
        dest_ref, allow_noent=True,
        flags=OSTree.RepoResolveRevExtFlags.REPO_RESOLVE_REV_EXT_NONE)
    if dest_parent is not None:
        logging.info('Using %s as new commit parent', dest_parent)

    # Make a copy of the commit metadata to update. Like flatpak
    # build-commit-from, the detached metadata is not copied since
    # the only known usage is for GPG signatures, which would become
    # invalid.
    commit_metadata = GLib.VariantDict.new(src_variant.get_child_value(0))

    # Set the collection binding if the repo has a collection ID,
    # otherwise remove it
    if collection_id is not None:
        commit_metadata.insert_value(
            OSTree.COMMIT_META_KEY_COLLECTION_BINDING,
            GLib.Variant('s', collection_id))
    else:
        commit_metadata.remove(
            OSTree.COMMIT_META_KEY_COLLECTION_BINDING)

    # Include the destination ref in the ref bindings
    ref_bindings = commit_metadata.lookup_value(
        OSTree.COMMIT_META_KEY_REF_BINDING,
        GLib.VariantType('as'))
    if ref_bindings is None:
        ref_bindings = []
    ref_bindings = set(ref_bindings)
    ref_bindings.add(dest_ref)
    commit_metadata.insert_value(
        OSTree.COMMIT_META_KEY_REF_BINDING,
        GLib.Variant('as', sorted(ref_bindings)))

    # Add flatpak specific metadata. xa.ref is deprecated, but some
    # flatpak clients might expect it. xa.from_commit will be used
    # by the app verifier to make sure the commit it sent actually
    # got there
    commit_metadata.insert_value('xa.ref',
                                 GLib.Variant('s', dest_ref))
    commit_metadata.insert_value('xa.from_commit',
                                 GLib.Variant('s', src_rev))

    # Convert from GVariantDict to GVariant vardict
    commit_metadata = commit_metadata.end()

    # Copy other commit data from source commit
    commit_subject = src_variant[COMMIT_SUBJECT_INDEX]
    commit_body = src_variant[COMMIT_BODY_INDEX]
    commit_time = OSTree.commit_get_timestamp(src_variant)

    # Make the new commit assuming the caller started a transaction
    mtree = OSTree.MutableTree.new()
    repo.write_directory_to_mtree(src_root, mtree, None)
    _, dest_root = repo.write_mtree(mtree)
    _, dest_checksum = repo.write_commit_with_time(dest_parent,
                                                   commit_subject,
                                                   commit_body,
                                                   commit_metadata,
                                                   dest_root,
                                                   commit_time)
    logging.info('Created new commit %s', dest_checksum)

    return dest_checksum


def _migrate_installed_flatpaks():
    insts = Flatpak.get_system_installations()
    inst = insts[0]
    refs = inst.list_installed_refs()

    # we need to also operate directly on the ostree refs that shadow each
    # flatpak so we don't leave behind local refs to the old origin and branch.
    repo = OSTree.Repo.new(inst.get_path().get_child('repo'))
    repo.open()
    _, ostree_refs = repo.list_refs() # dictionary of ref -> commit

    for migrate in FLATPAKS_TO_MIGRATE:
        kind = migrate['kind']
        old_origin = migrate['old-origin']

        name = migrate.get('name')
        prefix = migrate.get('prefix')
        assert name or prefix

        old_branch = migrate.get('old-branch')

        # we build what should be the same list twice - from the flatpak
        # perspective by examining the installation and deployed apps, and from
        # the ostree perspective by examining the refs in the repo. ordinarily
        # we would only see them differ due to a bug in previous versions of
        # this script where the refs were not renamed during a migration.
        # everything in the matching_ostree_refs list will be copied to its
        # new name if we change (or previously changed) the branch or origin,
        # and then deleted after the deployed apps are updated. (T22763)
        matching_refs = _filter_refs(refs, name=name, prefix=prefix, kind=kind,
                                     branch=old_branch, origin=old_origin)
        matching_ostree_refs = _filter_ostree_refs(ostree_refs.keys(),
                                                   old_origin, kind,
                                                   name=name, prefix=prefix,
                                                   branch=old_branch)

        # also search for name.* runtimes to migrate to catch extensions
        # unless we are already searching runtimes by prefix - in this case
        # we will already have found the matching extensions
        if name or kind == Flatpak.RefKind.APP:
            if not prefix:
                prefix = name + '.'
            matching_refs += _filter_refs(refs, prefix=prefix,
                                          kind=Flatpak.RefKind.RUNTIME,
                                          branch=old_branch, origin=old_origin)

            matching_ostree_refs += _filter_ostree_refs(ostree_refs.keys(),
                                                        old_origin,
                                                        Flatpak.RefKind.RUNTIME,
                                                        prefix=prefix,
                                                        branch=old_branch)

        if len(matching_refs) == 0:
            if name:
                logging.debug('Found no matches to migrate for {} {}'
                              .format(kind.value_nick, name))
            else:
                logging.debug('Found no matches to migrate for {} {}*'
                              .format(kind.value_nick, prefix))

        for ref in matching_refs:
            origin = ref.get_origin()
            name = ref.get_name()
            arch = ref.get_arch()
            branch = ref.get_branch()
            old_ostree_ref = '{}:{}'.format(origin, ref.format_ref())

            new_origin = migrate.get('new-origin', origin)
            new_branch = migrate.get('new-branch', branch)
            new_ostree_ref = '{}:{}/{}/{}/{}'.format(new_origin, kind.value_nick,
                                                     name, arch, new_branch)

            logging.info('Found {} to migrate to {}'.format(old_ostree_ref,
                         new_ostree_ref))

            # if we're not changing anything, why are we here?
            assert (old_ostree_ref != new_ostree_ref)

            try:
                # copy the old ref to the new one, pointing at the same commit
                if old_ostree_ref in ostree_refs and \
                   not new_ostree_ref in ostree_refs:
                    logging.info('Copying OSTree ref {} [{}] to {}'
                                 .format(old_ostree_ref,
                                         ostree_refs[old_ostree_ref],
                                         new_ostree_ref))
                    try:
                        repo.prepare_transaction()
                        new_commit = copy_commit(repo,
                                                 ostree_refs[old_ostree_ref],
                                                 new_ostree_ref.split(':')[1])
                        repo.commit_transaction()
                    except:
                        repo.abort_transaction()
                        raise
                    repo.set_ref_immediate(new_origin,
                                           new_ostree_ref.split(':')[1],
                                           new_commit)
                    ostree_refs[new_ostree_ref] = new_commit

                if new_branch != branch:
                    try:
                        new_ref = inst.get_installed_ref(kind, name, arch,
                                                         new_branch)
                        logging.info('Found already installed: {}'
                                     .format(ref.format_ref()))

                        # adopt installed origin if app was already installed
                        new_origin = ref.get_origin()
                    except GLib.GError as e:
                        if not e.matches(Flatpak.error_quark(),
                                         Flatpak.Error.NOT_INSTALLED):
                            raise

                        new_ref = None

                    if not new_ref:
                        logging.info('Deploying with new ref: {}'.format(new_ostree_ref))
                        new_ref = inst.install_full(Flatpak.InstallFlags.NO_PULL, new_origin,
                                                    kind, name, arch, new_branch)

                    logging.info('Uninstalling old ref: {}'.format(old_ostree_ref))
                    inst.uninstall_full(Flatpak.UninstallFlags.NO_PRUNE, kind,
                                        name, arch, branch)

                    ref = new_ref
                    origin = new_origin

                deploy_dir = ref.get_deploy_dir()
                deploy = os.path.join(deploy_dir, 'deploy')

                if new_origin != origin:
                    _update_deploy_file_with_origin(deploy, new_origin)

            except Exception:
                logging.exception('Failure applying migration to {}'
                                  .format(name))
                # preserve the old ref so that the migration can be re-attempted
                matching_ostree_refs.remove(old_ostree_ref)
                continue

        # any refs we copied, along with any matches for apps we migrated
        # in the past, should be deleted.
        for old_ostree_ref in matching_ostree_refs:
            try:
                logging.info('Deleting old/stale OSTree ref {} [{}]'
                             .format(old_ostree_ref,
                                     ostree_refs[old_ostree_ref]))
                repo.set_ref_immediate(old_ostree_ref.split(':')[0],
                                       old_ostree_ref.split(':')[1],
                                       None)
            except Exception:
                logging.exception('Failure deleting ref {}'
                                  .format(old_ostree_ref))
                continue


if __name__ == '__main__':
    # Send logging messages both to the console and the journal
    logging.basicConfig(level=logging.INFO)
    logging.root.addHandler(journal.JournalHandler())

    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', '-d', dest='debug', action='store_true')
    parsed_args, otherargs = parser.parse_known_args()

    if parsed_args.debug:
        logging.root.setLevel(logging.DEBUG)

    # ensure default remotes exist, such as eos-sdk and flathub
    _add_flatpak_repos()

    # remove any unused refs, remotes and runtimes
    _remove_ostree_refs()
    _remove_remotes()
    _remove_runtimes()

    # move apps and runtimes between branches and origins as specified above
    _migrate_installed_flatpaks()
